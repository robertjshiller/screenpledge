// lib/main.dart

// Original comments are retained.
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:screenpledge/core/config/theme/app_theme.dart';
import 'package:screenpledge/features/auth/presentation/views/auth_gate.dart';
import 'package:screenpledge/core/data/datasources/revenuecat_remote_datasource.dart';
import 'package:supabase_flutter/supabase_flutter.dart';
import 'package:flutter_dotenv/flutter_dotenv.dart';
import 'package:flutter_stripe/flutter_stripe.dart';
import 'package:workmanager/workmanager.dart';
import 'package:screenpledge/core/services/background_task_handler.dart';
import 'package:screenpledge/core/services/notification_service.dart';

// The top-level callbackDispatcher now uses the constants from the handler file.
@pragma('vm:entry-point')
void callbackDispatcher() {
  Workmanager().executeTask((task, inputData) async {
    // ✅ CHANGED: We now create a dedicated handler for each task type
    // to ensure a clean separation of concerns.
    switch (task) {
      case dailyDataSubmissionTask:
        final handler = DailyDataSubmissionHandler();
        return await handler.submitDailyData(); // Return the result of the handler.
      case warningNotificationTask:
        final handler = WarningNotificationHandler();
        return await handler.runWarningChecks(); // Return the result of the handler.
      default:
        return Future.value(true);
    }
  });
}

/// The main entry point for the ScreenPledge application.
void main() async {
  WidgetsFlutterBinding.ensureInitialized();
  await dotenv.load(fileName: ".env");

  await Supabase.initialize(
    url: dotenv.env['SUPABASE_URL']!,
    anonKey: dotenv.env['SUPABASE_ANON_KEY']!,
  );

  Stripe.publishableKey = dotenv.env['STRIPE_PUBLISHABLE_KEY']!;
  await Stripe.instance.applySettings();

  await NotificationService.initialize();

  await Workmanager().initialize(
    callbackDispatcher,
    isInDebugMode: true,
  );

  // ✅ CHANGED: We now register our two distinct tasks with clear policies.
  
  // 1. The daily data submission task. This is a high-reliability periodic task.
  Workmanager().registerPeriodicTask(
    "dailyDataSubmissionTask-unique", // A unique name for the registration.
    // ✅ FIX: Corrected the typo in the task name.
    dailyDataSubmissionTask,     // The name of the task itself.
    frequency: const Duration(hours: 12), // Run roughly every 12 hours to ensure it doesn't miss.
    existingWorkPolicy: ExistingWorkPolicy.keep,
    // This task requires a network connection to submit data.
    constraints: Constraints(networkType: NetworkType.connected),
  );

  // 2. The warning notification task. This is a chained one-time task.
  // We register it here to kick off the chain for the first time when the app starts.
  // The task will then be responsible for rescheduling itself.
  Workmanager().registerOneOffTask(
    "initialWarningTask-unique", // Unique name for the very first registration.
    warningNotificationTask,
    existingWorkPolicy: ExistingWorkPolicy.keep, // Don't re-register if one is already queued.
    initialDelay: const Duration(minutes: 1), // Start the first check shortly after app launch.
    // This task must be able to run without a network connection.
    constraints: Constraints(networkType: NetworkType.not_required),
  );

  final rcDataSource = RevenueCatRemoteDataSource(
    androidPublicApiKey: dotenv.env['REVENUECAT_ANDROID_API_KEY'] ?? 'YOUR_ANDROID_PUBLIC_KEY',
    iosPublicApiKey: dotenv.env['REVENUECAT_IOS_API_KEY'] ?? 'YOUR_IOS_PUBLIC_KEY',
    defaultOfferingId: 'default',
    enableDebugLogs: true,
  );
  await rcDataSource.configure();

  runApp(
    const ProviderScope(
      child: ScreenPledgeApp(),
    ),
  );
}

// The ScreenPledgeApp widget remains unchanged.
class ScreenPledgeApp extends StatelessWidget {
  const ScreenPledgeApp({super.key});

  @override
  Widget build(BuildContext context) {
    return MaterialApp(
      title: 'ScreenPledge',
      theme: AppTheme.themeData,
      home: const AuthGate(),
      debugShowCheckedModeBanner: false,
    );
  }
}